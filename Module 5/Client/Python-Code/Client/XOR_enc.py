import string # the random and string libraries are used to generate a random string with flexible criteria
import random


# random key generator to creat a string with a size of 1024 bytes containing lower + upper case, digits and special characters
# the for loop defines the key size, key size is 1 KB which matches our the TCP socket size
# the "".joinwill put the result for the random strings into a sequqnece which we finally store in a key variable 
key = ''.join(random.choice(string.ascii_lowercase + string.ascii_uppercase + string.digits + '^!\$%&/()=?{[]}+~#-_.:,;<>|\\') for _ in range(1024))

print key
print '\n' + 'Key length = ' + str(len(key))

# REMINDER 1
# --> make sure that the SAME Key is HARDCODED in the Server AND client, ohterwise you won't be able to decode your own messages!
# REMINDER 2
# take into consideration the XOR encrytpion rule which says the key length must be greater or equal the msg/data
# --> len(key) >= len(message) 

# this is the message which we will encrypt before it's getting sent
message = 'ipconfig'
print "Msg is " + message + '\n'


# function to en/decrypt messages - just one function, because xor operation for en/decrpyt is the same, just parameter matters
# params: s1 message, s2 xor key
#
# first we split the message and the xor key to a list of character pair in tuples format >> for (c1,c2) in zip(s1,s2)
# next we will go through each tuple, and converting them to integer using (ord) function
# once they converted into integers we can now perform exclusive OR on them  >>  ord(c1) ^ ord(c2)
# last step we will merge the resulting array of characters as a sequqnece string using >>>  "".join function 
def str_xor(s1, s2):
    return "".join([chr(ord(c1) ^ ord(c2)) for (c1,c2) in zip(s1,s2)])



# test en/decryption

enc = str_xor(message, key)
print 'Encrypted messge is: ' + '\n' + enc + '\n' 

dec = str_xor(enc, key)
print 'Decrypted messge is: ' + '\n' + dec





